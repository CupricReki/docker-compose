"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocationModeSwitch = void 0;
const operators_1 = require("rxjs/operators");
const hap_1 = require("./hap");
const util_1 = require("../api/util");
const base_accessory_1 = require("./base-accessory");
const rxjs_1 = require("rxjs");
function getStateFromMode(mode) {
    const { Characteristic: { SecuritySystemCurrentState: State }, } = hap_1.hap;
    switch (mode) {
        case 'away':
            return State.AWAY_ARM;
        case 'home':
            return State.STAY_ARM;
        case 'disarmed':
            return State.DISARMED;
        default:
            return State.DISARMED;
    }
}
class LocationModeSwitch extends base_accessory_1.BaseAccessory {
    constructor(location, accessory, logger, config) {
        super();
        this.location = location;
        this.accessory = accessory;
        this.logger = logger;
        this.config = config;
        this.device = this.location; // for use in BaseAccessory
        const { Characteristic, Service: { SecuritySystem, AccessoryInformation }, } = hap_1.hap, accessoryName = location.name + ' Mode', service = this.getService(SecuritySystem, accessoryName), currentState = service.getCharacteristic(Characteristic.SecuritySystemCurrentState), targetState = service.getCharacteristic(Characteristic.SecuritySystemTargetState), getCurrentMode = () => {
            return (0, rxjs_1.firstValueFrom)(location.onLocationMode);
        }, getCurrentState = () => __awaiter(this, void 0, void 0, function* () { return getStateFromMode(yield getCurrentMode()); });
        location.onLocationMode.pipe((0, operators_1.distinctUntilChanged)()).subscribe((mode) => {
            const state = getStateFromMode(mode);
            if (state === this.targetState) {
                this.targetState = undefined;
            }
            if (!this.targetState) {
                targetState.updateValue(state);
            }
            currentState.updateValue(state);
        });
        currentState.on("get" /* GET */, (callback) => __awaiter(this, void 0, void 0, function* () {
            location.getLocationMode().catch((e) => {
                (0, util_1.logError)('Failed to retrieve location mode for ' + location.name);
                (0, util_1.logError)(e);
            });
            const state = yield getCurrentState();
            if (state === this.targetState) {
                this.targetState = undefined;
            }
            callback(null, state);
        }));
        targetState.on("get" /* GET */, (callback) => __awaiter(this, void 0, void 0, function* () {
            callback(null, this.targetState !== undefined
                ? this.targetState
                : yield getCurrentState());
        }));
        targetState.on("set" /* SET */, (state, callback) => __awaiter(this, void 0, void 0, function* () {
            const { Characteristic: { SecuritySystemTargetState: State }, } = hap_1.hap;
            callback();
            if (state === State.NIGHT_ARM) {
                state = State.STAY_ARM;
                // Ring doesn't have night mode, so switch over to stay mode
                setTimeout(() => targetState.updateValue(state), 100);
            }
            if (state === (yield getCurrentState())) {
                this.targetState = undefined;
                return;
            }
            this.targetState = state;
            if (state === State.AWAY_ARM) {
                this.logger.info(`Setting ${this.location.name} Mode to away`);
                return this.location.setLocationMode('away');
            }
            else if (state === State.DISARM) {
                this.logger.info(`Setting ${this.location.name} Mode to disarmed`);
                return this.location.setLocationMode('disarmed');
            }
            this.logger.info(`Setting ${this.location.name} Mode to home`);
            return this.location.setLocationMode('home');
        }));
        targetState.setProps({
            validValues: [
                Characteristic.SecuritySystemTargetState.AWAY_ARM,
                Characteristic.SecuritySystemTargetState.STAY_ARM,
                Characteristic.SecuritySystemTargetState.DISARM,
            ],
        });
        this.registerObservableCharacteristic({
            characteristicType: Characteristic.Manufacturer,
            serviceType: AccessoryInformation,
            onValue: (0, rxjs_1.of)('Ring'),
        });
        this.registerObservableCharacteristic({
            characteristicType: Characteristic.Model,
            serviceType: AccessoryInformation,
            onValue: (0, rxjs_1.of)('Location Mode'),
        });
        this.registerObservableCharacteristic({
            characteristicType: Characteristic.SerialNumber,
            serviceType: AccessoryInformation,
            onValue: (0, rxjs_1.of)('N/A'),
        });
    }
}
exports.LocationModeSwitch = LocationModeSwitch;
