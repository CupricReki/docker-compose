"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseDataAccessory = void 0;
const base_accessory_1 = require("./base-accessory");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
class BaseDataAccessory extends base_accessory_1.BaseAccessory {
    registerCharacteristic({ characteristicType, serviceType, getValue, setValue, setValueDebounceTime = 0, name, requestUpdate, serviceSubType, }) {
        const service = this.getService(serviceType, name, serviceSubType), characteristic = service.getCharacteristic(characteristicType), { device } = this;
        if (requestUpdate) {
            // Only register for GET if an async request should be made to get an updated value
            characteristic.on("get" /* GET */, (callback) => {
                try {
                    const value = getValue(device.data);
                    callback(null, value);
                    requestUpdate();
                }
                catch (e) {
                    callback(e);
                }
            });
        }
        if (setValue && setValueDebounceTime) {
            const onValueToSet = new rxjs_1.Subject();
            characteristic.on("set" /* SET */, (newValue, callback) => {
                onValueToSet.next(newValue);
                callback();
            });
            onValueToSet.pipe((0, operators_1.debounceTime)(setValueDebounceTime)).subscribe(setValue);
        }
        else if (setValue) {
            characteristic.on("set" /* SET */, (newValue, callback) => {
                Promise.resolve(setValue(newValue)).catch((e) => {
                    this.logger.error(e);
                });
                callback();
            });
        }
        ;
        this.device.onData
            .pipe((0, operators_1.map)(getValue), (0, operators_1.distinctUntilChanged)())
            .subscribe((value) => characteristic.updateValue(value));
    }
    registerLevelCharacteristic({ characteristicType, serviceType, getValue, setValue, requestUpdate, }) {
        let targetLevel;
        this.registerCharacteristic({
            characteristicType,
            serviceType,
            getValue: (data) => {
                const newLevel = getValue(data);
                if (newLevel === targetLevel) {
                    targetLevel = undefined;
                }
                return targetLevel === undefined ? newLevel : targetLevel;
            },
            setValue: (volume) => {
                targetLevel = volume;
                setValue(volume);
            },
            setValueDebounceTime: 500,
            requestUpdate,
        });
    }
}
exports.BaseDataAccessory = BaseDataAccessory;
